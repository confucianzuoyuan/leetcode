\documentclass[oneside,10pt,fontset=none]{ctexbook}
\usepackage{tocloft}
\setCJKmainfont[BoldFont={FZHei-B01},ItalicFont={FZKai-Z03}]{FZShuSong-Z01}
\setCJKsansfont[BoldFont={FZHei-B01}]{FZKai-Z03}
\setCJKmonofont[BoldFont={FZHei-B01}]{FZFangSong-Z02}
\renewcommand{\cfttoctitlefont}{\sffamily}
\renewcommand{\cftpartfont}{\sffamily}
\renewcommand{\cftchapfont}{\sffamily}
\renewcommand{\cftsecfont}{\sffamily}
\renewcommand{\cftsubsecfont}{\sffamily}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={数据结构与算法分析},
    pdfpagemode=FullScreen,
}
\usepackage{amsmath}
\usepackage[screen]{clrscode4e}
\usepackage{tikz}
\usepackage{xcolor}

\title{数据结构与算法分析}
\author{左元}

\begin{document}

\maketitle
\tableofcontents

\part{基础知识}

这一部分将引导读者开始思考算法的设计和分析问题, 简单介绍算法的表达方法, 将在本书中用到的一些设计策略, 以及算法分析中用到的许多基本思想. 本课程后面的内容都是建立在这些基础知识之上的.

第1章是对算法及其在现代计算系统中地位的一个综述. 本章给出了算法的定义和一些算法的例子. 此外, 本章还说明了算法是一项技术, 就像快速的硬件、图形用户界面、面向对象系统和网络一样.

在第2章中, 我们给出了书中的第一批算法, 它们解决的是对$n$个数进行排序的间题. 这些算法是用一种伪代码形式给出的, 这种伪代码尽管不能直接翻译为任何常规的程序设计语言, 但是足够清晰地表达了算法的结构, 以便任何一位能力比较强的程序员都能用自己选择的语言将算法实现出来. 我们分析的排序算法是插入排序, 它采用了一种增量式的做法; 另外还分析了归并排序, 它采用了一种递归技术, 称为``分治法''. 尽管这两种算法所需的运行时间都随$n$的值而增长, 但增长的速度是不同的. 我们在第2章分析了这两种算法的运行时间, 并给出了一种有用的``渐进''表示法来表达这些运行时间.

第3章给出了这种表示法的准确定义, 称为渐近表示. 在第3章的一开始, 首先定义几种渐近符号, 它们主要用于表示算法运行时间的上界和下界. 第3章余下的部分主要给出了一些数学表示方法. 这一部分的作用更多的是为了确保读者所用的记号能与本书的记号体系相匹配, 而不是教授新的数学概念.

第4章更深入地讨论了第2章引入的分治法, 给出了更多分治法的例子. 第4章包含了求解递归式的方法. 递归式用于描述递归算法的运行时间. ``主方法''是一种功能很强的技术, 通常用于解决分治算法中出现的递归式.

\chapter{算法在计算中的作用}

什么是算法? 为什么算法值得研究? 相对于计算机中使用的其他技术来说算法的作用是什么? 本章我们将回答这些问题.

\section{算法}

非形式地说, \textbf{算法}(algorithm)就是任何经过良好的定义的计算过程, 这个过程取某个值或值的集合作为\textbf{输入}并在有限的时间内产生某个值或值的集合作为\textbf{输出}. 这样算法就是把输入转换成输出的计算步骤的一个序列.

我们也可以把算法看成是用于求解良说明的\textbf{计算问题}的工具. 一般来说, 问题陈述说明了期望的输入/输出关系. 算法则描述一个特定的计算过程来实现该输入/输出关系.

例如, 我们可能需要把一个数列排成非递减序. 实际上, 这个问题经常出现, 并且为引入许多标准的设计技术和分析工具提供了足够的理由. 下面是我们关于\textbf{排序问题}的形式化定义.

\textbf{输入}: $N$个数的一个序列$\langle a_1, a_2, \dots, a_n\rangle$.

\textbf{输出}: 输入序列的一个排列$\langle a'_1, a'_2, \dots, a'_n\rangle , \text{满足}\langle a'_0\leq a'_1 \leq\cdots a'_n\rangle$.

例如, 给定输入序列 $\langle 31, 41, 59, 26, 41, 58\rangle$, 排序算法将返回序列 $\langle 26, 31, 41,$ $ 41, 58, 59\rangle$ 作为输出. 这样的输入序列称为排序问题的一个\textbf{实例}(instance). 一般来说, 问题实例由计算该问题解所必需的(满足问题陈述中强加的各种约束的)输入组成.

因为许多程序使用排序作为一个中间步, 所以排序是计算机科学中的一个基本操作. 因此, 已有许多好的排序算法供我们任意使用. 对于给定应用, 哪个算法最好依赖于以下因素: 将被排序的项数, 这些项巳被稍微排序的程度, 关于项值的可能限制, 计算机的体系结构, 以及将使用的存储设备的种类(主存, 磁盘或者磁带).

若对每个输入实例算法都以正确的输出\textbf{停机}(halt)--在有限的时间内结束, 则称该算法是正确的, 并称正确的算法解决了给定的计算问题. 不正确的算法对某些输入实例可能根本不停机, 也可能以不正确的回答停机. 与人们期望的相反, 不正确的算法只要其错误率可控有时可能是有用的. 但是通常我们只关心正确的算法.

算法可以用自然语言来说明, 也可以说明成计算机程序, 甚至说明成硬件设计. 唯一的要求是这个说明必须精确描述所要遵循的计算过程.

\textbf{算法解决哪种问题}

排序绝不是已开发算法的唯一计算问题, 算法的实际应用无处不在, 包括以下例子:

\begin{itemize}
    \item 人类基因工程已经取得重大进展, 其目标是识别人类DNA中的所有10万个基因, 确定构成人类DNA的30亿个化学基对的序列, 在数据库中存储这类信息并为数据分析开发工具. 这些工作都需要复杂的算法. 虽然对涉及的各种问题的求解超出了本课程的范围, 但是求解这些生物问题的许多方法采用了本课程多章内容的思想, 从而使得科学家能够有效地使用资源以完成任务. 因为可以从实验技术中提取更多的信息, 所以既能节省人和机器的时间又能节省金钱.
    \item 互联网使得全世界的人都能快速地访问与检索大量信息. 借助于一些聪明的算法, 互联网上的网站能够管理和处理这些海量数据. 必须使用算法的问题示例包括为数据传输寻找好的路由, 使用一个搜索引擎来快速地找到特定信息所在的网页.
    \item 电子商务使得货物与服务能够以电子方式洽谈与交换, 并且它依赖于像信用卡号, 密码和银行结单这类个人信息的保密性. 电子商务中使用的核心技术包括公钥密码与数字签名, 它们以数值算法和数论为基础.
\end{itemize}

虽然这些例子的一些细节已超出本书的范围, 但是我们确实说明了一些适用于这些问题和问题领域的基本技术. 我们还说明如何求解许多具体问题, 包括以下问题:

\begin{itemize}
    \item 给定一张交通图, 上面标记了每对相邻十字路口之间的距离, 我们希望确定从一个十字路口到另一个十字路口的最短道路. 即使不允许穿过自身的道路, 可能路线的数量也会很大. 在所有可能路线中, 我们如何选择哪一条是最短的? 这里首先把交通图(它本身就是实际道路的一个模型)建模为一个图, 然后寻找图中从一个顶点到另一个顶点的最短路径.
    \item 给定两个有序的符号序列$X = \langle x_1, x_2, \dots, x_m\rangle$和$Y=\langle y_1, y_2, \dots, y_n\rangle$, 求出$X$和$Y$的最长公共子序列. $X$的子序列就是去掉一些元素(可能是所有, 也可能一个没有)后的$X$. 例如, $\langle A, B, C, D, E, F, G\rangle$的一个子序列是$\langle B, C, E, G\rangle$. $X$和$Y$的最长公共子序列的长度度量了这两个序列的相似程序. 例如, 若两个序列是DNA链中的基对, 则当它们具有长的公共子序列时我们认为它们是相似的. 若$X$有$m$个符号且$Y$有$n$个符号, 则$X$和$Y$分别有2个可能的子序列. 除非$m$和$n$很小, 否则选择$X$和$Y$的所有可能子序列做匹配将花费使人望而却步多的时间. 我们将使用\textbf{动态规划}技术来解决这个问题.
    \item 给定一个依据部件库的机械设计, 其中每个部件可能包含其他部件的实例, 我们需要依次列出这些部件, 以使每个部件出现在使用它的任何部件之前. 若该设计由$n$个部件组成, 则存在$n!$种可能的顺序, 其中$n!$表示阶乘函数. 因为阶乘函数甚至比指数函数增长还快, (除非我们只有几个部件, 否则)先生成每种可能的顺序再验证按该顺序每个部件出现在使用它的部件之前, 是不可行的. 我们将使用\textbf{拓扑排序}算法来解决这个问题.
\end{itemize}

虽然这些问题的列表还远未穷尽, 但是它们却展示了许多有趣的算法问题所共有的两个特征:

\begin{enumerate}
    \item 存在许多候选解, 但绝大多数候选解都没有解决手头的问题. 寻找一个真正的解或一个最好的解可能是一个很大的挑战.
    \item 存在实际应用. 在上面所列的问题中, 最短路径问题提供了最易懂的例子. 一家运输公司(如公路运输或铁路运输公司)对如何在公路或铁路网中找出最短路径, 有着经济方面的利益, 因为采用的路径越短, 其人力和燃料的开销就越低. 互联网上的一个路由结点为了快速地发送一条消息可能需要寻找通过网络的最短路径. 希望从北京开车去上海的人可能想从一个恰当的网站寻找开车方向, 或者开车时她可能使用其GPS.
\end{enumerate}

\textbf{数据结构}

本课程也包含几种数据结构. 数据结构是一种存储和组织数据的方式, 旨在便于访问和修改. 没有一种单一的数据结构对所有用途均有效, 所以重要的是知道几种数据结构的优势和局限.

\textbf{技术}

虽然可以把本课程当做一本有关算法的``菜谱''来使用, 但是也许在某一天你会遇到一个问题, 一时无法很快找到一个已有的算法来解决它. 本课程将教你一些算法设计与分析的技术, 以便你能自行设计算法, 证明其正确性和理解其效率. 不同的章介绍算法问题求解的不同方面.

\section{作为一种技术的算法}

假设计算机是无限快的并且计算机存储器是免费的, 你还有什么理由来研究算法吗? 即使只是因为你还想证明你的解法会终止并以正确的答案终止, 那么回答也是肯定的.

如果计算机无限快, 那么用于求解某个问题的任何正确的方法都行. 也许你希望你的实现在好的软件工程实践的范围内(例如, 你的实现应该具有良好的设计与文档), 但是你最常使用的
是最容易实现的方法.

当然, 计算机也许是快的, 但它们不是无限快. 存储器也许是廉价的, 但不是免费的. 所以计算时间是一种有限资源, 存储器中的空间也一样. 你应该明智地使用这些资源, 在时间或空间方面有效的算法将帮助你这样使用资源.

\textbf{效率}

为求解相同问题而设计的不同算法在效率方面常常具有显著的差别. 这些差别可能比由于硬件和软件造成的差别要重要得多.

作为一个例子, 第2章将介绍两个用于排序的算法. 第一个称为插入排序, 为了排序$n$个项, 该算法所花时间大致等于$c_1n^2$, 其中$c_1$是一个不依赖于$n$的常数. 也就是说, 该算法所花时间大致与$n^2$成正比. 第二个称为归并排序, 为了排序$n$个项, 该算法所花时间大致等于$c_2n\lg{n}$, 其中$\lg{n}$代表$\log_2n$且$c_2$是另一个不依赖于$n$的常数. 与归并排序相比, 插入排序通常具有一个较小的常数因子, 所以$c_1<c_2$. 我们将看到就运行时间来说, 常数因子可能远没有对输入规模$n$的依赖性重要. 把插入排序的运行时间写成$c_1n\cdot n$并把归并排序的运行时间写成$c_2n\cdot \lg{n}$. 这时就运行时间来说, 插入排序有一个因子$n$的地方归并排序有一个因子$\lg{n}$, 后者要小得多. (例如, 当$n=1000$时, $\lg{n}$大致为10, 当$n$等于100万时, $\lg{n}$大致仅为20.)虽然对于小的输入规模, 插入排序通常比归并排序要快, 但是一旦输入规模$n$变得足够大, 归并排序$\lg{n}$对$n$的优点将足以补偿常数因子的差别. 不管$c_1$比$c_2$小多少, 总会存在一个交叉点, 超出这个点, 归并排序更快.

作为一个具体的例子, 我们让运行插入排序的一台较快的计算机(计算机A)与运行归并排序的一台较慢的计算机(计算机B)竞争. 每台计算机必须排序一个具有1000万个数的数组.(虽然1000万个数似乎很多, 但是, 如果这些数是8字节的整数, 那么输入将占用大致80MB, 即使一台便宜的便携式计算机的存储器也能多次装入这么多数.) 假设计算机A每秒执行百亿条指令(快于写本书时的任何单台串行计算机), 而计算机B每秒仅执行1000万条指令, 结果计算机A就纯计算能力来说比计算机B快1000倍. 为使差别更具戏剧性, 假设世上最巧妙的程序员为计算机A用机器语言编码插入排序, 并且为了排序$n$个数, 结果代码需要$2n^2$条指令. 进一步假设仅由一位水平一般的程序员使用某种带有一个低效编译器的高级语言来实现归并排序, 结果代码需要$50n\lg n$条指令. 为了排序$1000$万个数, 计算机A需要

$$
\frac{2\cdot (10^7)^2\text{条指令}}{10^10\text{条指令/秒}} = 20000\text{秒(多于5.5小时)}
$$

而计算机B需要

$$
\frac{50\cdot 10^7\lg{10^7}\text{条指令}}{10^10\text{条指令/秒}} \approx 1163\text{秒(少于20分钟)}
$$

通过使用一个运行时间增长较慢的算法, 即使采用一个较差的编译器, 计算机B比计算机A还快17倍! 当我们排序1亿个数时, 归并排序的优势甚至更明显: 这时插入排序需要23天多, 而归并排序不超过4小时. 一般来说, 随着问题规模的增大, 归并排序的相对优势也会增大.

\textbf{算法与其他技术}

上面的例子表明我们应该像计算机硬件一样把算法看成是一种技术. 整个系统的性能不但依赖于选择快速的硬件而且还依赖于选择有效的算法. 正如其他计算机技术正在快速推进一样, 算法也在快速发展.

你也许想知道相对其他先进的计算机技术(如以下列出的), 算法对于当代计算机是否真的那么重要:

\begin{itemize}
    \item 先进的计算机体系结构与制造技术
    \item 易于使用, 直观的图形用户界面(GUI)
    \item 面向对象的系统
    \item 集成的万维网技术
    \item 有线与无线网络的快速组网
\end{itemize}

回答是肯定的. 虽然某些应用在应用层不明确需要算法内容(如某些简单的基于万维网的应用), 但是许多应用确实需要算法内容. 例如, 考虑一种基于万维网的服务, 它确定如何从一个位置旅行到另一个位置. 其实现依赖于快速的硬件, 一个图形用户界面, 广域网, 还可能依赖于面向对象技术. 然而, 对某些操作, 如寻找路线(可能使用最短路径算法), 描绘地图, 插入地址, 它还是需要算法.

而且, 即使是那些在应用层不需要算法内容的应用也高度依赖于算法. 该应用依赖于快速的硬件吗? 硬件设计用到算法. 该应用依赖于图形用户界面吗? 任何图形用户界面的设计都依赖于算法. 该应用依赖于网络吗? 网络中的路由高度依赖于算法. 该应用采用一种不同于机器代码的语言来书写吗? 那么它被某个编译器, 解释器或汇编器处理过, 所有这些都广泛地使用算法. 算法是当代计算机中使用的大多数技术的核心.

进一步, 随着计算机能力的不断增强, 我们使用计算机来求解比以前更大的问题. 正如我们在上面对插入排序与归并排序的比较中所看到的, 正是在较大问题规模时, 算法之间效率的差别才变得特别显著.

是否具有算法知识与技术的坚实基础是区分真正熟练的程序员与初学者的一个特征. 使用现代计算技术, 如果你对算法懂得不多, 你也可以完成一些任务, 但是, 如果有一个好的算法背景, 那么你可以做的事情就多得多.

\chapter{算法基础}

本章将要介绍一个贯穿本书的框架, 后续的算法设计与分析都是在这个框架中进行的. 这一部分内容基本上是独立的, 但也有对第3章和第4章中一些内容的引用.

首先, 我们考察求解第1章中引入的排序问题的插入排序算法. 我们定义一种对于已经编写过计算机程序的读者来说应该熟悉的``伪代码'', 并用它来表明我们将如何说明算法. 然后, 在说明了插入排序算法后, 我们将证明该算法能正确地排序并分析其运行时间. 这种分析引入了一种记号, 该记号关注时间如何随着将被排序的项数而增加. 在讨论完插入排序之后, 我们引入用于算法设计的分治法并使用这种方法开发一个称为归并排序的算法. 最后, 我们分析归并排序的运行时间.

\section{插入排序}

我们的第一个算法(插入排序)求解第1章中引入的排序问题:

\textbf{输入}: $n$个数的一个序列$\langle a_1, a_2, \dots, a_n\rangle$.

\textbf{输出}: 输入序列的一个排列$\langle a'_1, a'_2, \dots, a'_n\rangle$, 满足$\langle a'_1\leq a'_2\leq\cdots\leq a'_n\rangle$.

我们希望排序的数也称为\textbf{key}. 虽然概念上我们在排序一个序列, 但是输入是以$n$个元素的数组的形式出现的.

本教程中, 我们通常将算法描述为用一种伪代码书写的程序, 该伪代码在许多方面类似于Java. 伪代码与真正的代码的区别在于, 在伪代码中, 我们使用最清晰, 最简洁的表示方法来说明给定的算法. 有时最清晰的表示方法是自然语言, 所以如果你遇到一个自然语言短语或句子嵌入在一段伪代码中就不要吃惊. 伪代码与真正的代码的另一个区别是伪代码通常不关心软件工程的问题. 为了更简洁地表达算法的本质, 常常忽略数据抽象, 模块性和错误处理的问题.

我们首先介绍插入排序, 对于少量元素的排序, 它是一个有效的算法. 插入排序的工作方式像许多人排序一手扑克牌. 开始时, 我们的左手为空并且桌子上的牌面向下. 然后. 我们每次从桌子上拿走一张牌并将它插入左手中正确的位置. 为了找到一张牌的正确位置, 我们从右到左将它与已在手中的每张牌进行比较. 拿在左手上的牌总是排序好的, 原来这些牌是桌子上牌堆中顶部的牌.

对于插入排序, 我们将其伪代码过程命名为\proc{Insertion-Sort}, 它接收两个参数: 一个参数是数组$A$, 包含了将被排序的数组元素, 另一个参数是$n$, 表示数组的长度. 数组元素占据$A[1]$到$A[n]$的位置, 我们表示为$A[1:n]$. 当\proc{Insertion-Sort}程序执行完毕时, 数组$A[1:n]$包含了已经排过序的原始数组中的所有元素.

\begin{codebox}
\Procname{$\proc{Insertion-Sort}(A, n)$}
\li \For $i \gets 2$ \To $n$
\li \Do
$\id{key} \gets A[i]$
\li \Comment{将 $A[i]$ 插入到已经排好序的子数组 $A[1 \subarr i-1]$.}
\li $j \gets i-1$
\li \While $j > 0$ and $A[j] > \id{key}$
\li \Do
$A[j+1] \gets A[j]$
\li $j \gets j-1$
\End
\li $A[j+1] \gets \id{key}$
\End
\end{codebox}

\textbf{循环不变量与插入排序的正确性}

图\ref{fig:插入排序示意图}表明对$A=\langle 5, 2, 4, 6, 1, 3\rangle$数组插入排序算法如何工作. 下标 $i$ 指出正被插入到手中的``当前牌''. 在 \kw{for} 循环(循环变量为$i$)的每次迭代的开始, 包含元素 $A[1:i—1]$ 的\textbf{子数组}构成了当前排序好的左手中的牌, 剩余的子数组 $A[i+1:n]$ 对应于仍在桌子上的牌堆. 事实上, 元素 $A[1:i—1]$ 就是原来在位置 $1$ 到 $i—1$ 的元素, 但现在已按序排列. 我们把 $A[1:i-1]$ 的这些性质形式地表示为一个\textbf{循环不变量}:

\input{figures/插入排序示意图.tex}

在每次\kw{for}迭代(1-8行)开始时, 子数组$A[1:i-1]$包括了最开始在$A[1:i-1]$中的数组元素, 但是已经经过了排序.

循环不变量主要用来帮助我们理解算法的正确性. 关于循环不变量. 我们必须证明三条性质:

\textbf{初始化}: 循环的第一次迭代之前. 它为真.

\textbf{保持}: 如果循环的某次迭代之前它为真. 那么下次迭代之前它仍为真.

\textbf{终止}: 在循环终止时. 不变量为我们提供一个有用的性质. 该性质有助于证明算法是正确的.

当前两条性质成立时. 在循环的每次迭代之前循环不变量为真.(当然, 为了证明循环不变量在每次迭代之前保持为真, 我们完全可以使用不同于循环不变量本身的其它已证实的事实.) 注意, 这类似于数学归纳法, 其中为了证明某条性质成立, 需要证明一个\textbf{基准情况}和一个\textbf{归纳步骤}. 这里, 证明第一次迭代之前不变量成立对应于基准情况, 证明从一次迭代到下一次迭代不变量成立对应于归纳步骤.

第三条性质也许是最重要的. 因为我们将使用循环不变量来证明程序的正确性. 通常, 我们和导致循环终止的条件一起使用循环不变量, 终止性不同于我们通常使用数学归纳法的做法, 在归纳法中, 归纳步骤是无限地使用的, 这里当循环终止时, 停止``归纳''.

让我们看看对于插入排序, 如何证明这些性质成立.

\textbf{初始化}: 首先证明在第一次循环迭代之前(当 $i=2$ 时), 循环不变量成立. 所以子数组 $A[1:i-1]$ 仅由单个元素 $A[1]$ 组成, 实际上就是 $A[1]$ 中原来的元素. 而且该子数组是排序好的(当然很平凡). 这表明第一次循环迭代之前循环不变量成立.

\textbf{保持}: 其次处理第二条性质: 证明每次迭代保持循环不变量. 非形式化地, \kw{for} 循环体的第 4-7 行将 $A[i-1], A[i—2], A[i-3]$ 等向右移动一个位置, 直到找到 $A[i]$ 的适当位置, 第 8 行将 $A[i]$ 的值插入该位置. 这时子数组 $A[1:i]$ 由原来在 $A[1:i]$ 中的元素组成, 但已按序排列. 那么对 \kw{for} 循环的下一次迭代增加 $i$ 将保持循环不变量.

第二条性质的一种更形式化的处理要求我们对第 5-7 行的 \kw{while} 循环给出并证明一个循环不变量. 然而, 这里我们不愿陷入形式主义的困境, 而是依赖以上非形式化的分析来证明第二条性质对外层循环成立.

\textbf{终止}: 最后研究在循环终止时发生了什么. 导致 \kw{for} 循环终止的条件是 $i > n$. 因为每次循环迭代 $i$ 增加 1, 那么循环终止时, 必有 $i=n+1$. 在循环不变量的表述中将 $i$ 用 $n+1$ 代替, 我们有: 子数组 $A[1:n]$ 由原来在 $A[1:n]$ 中的元素组成, 但已按序排列. 注意到, 子数组 $A[1:n]$ 就是整个数组, 我们推断出整个数组已排序. 因此算法正确.

在本章后面以及其他章中, 我们将采用这种循环不变量的方法来证明算法的正确性.

\textbf{伪代码中的一些约定}

我们在伪代码中采用以下约定:

\begin{itemize}
    \item 缩进表示块结构. 例如, 第 1 行开始的 \kw{for} 循环体由第 2-8 行组成, 第 5 行开始的 \kw{while} 循环体包含第 6-7 行但不包含第 8 行. 我们的缩进风格也适用于 \kw{if}-\kw{else} 语句采用缩进来代替常规的块结构标志, 如 \kw{begin} 和 \kw{end} 语句, 可以大大提高代码的清晰性.
    \item \kw{while}, \kw{for} 与 \kw{repeat}-\kw{until} 等循环结构以及 \kw{if}-\kw{else} 等条件结构与 Java 中的那些结构类似. 本教程中在退出循环后, 循环计数器保持其值. 因此, 紧接在一个 \kw{for} 循环后, 循环计数器的值就是第一个超出 \kw{for} 循环界限的那个值. 在证明插入排序的正确性时, 我们使用了该性质. 第 1 行的 \kw{for} 循环头为 $\kw{for} i = 2 \kw{to} n$ , 所以, 当该循环终止时, $i=n+1$. 当一个 \kw{for} 循环每次迭代增加其循环计数器时, 我们使用关键词 \kw{to}. 当一个 \kw{for} 循环每次迭代减少其循环计数器时, 我们使用关键词 \kw{downto}. 当循环计数器以大于 1 的一个量改变时, 该改变量跟在可选关键词 \kw{by} 之后.
    \item 符号 ``\Comment{}'' 表示该行后面部分是个注释.
    \item 变量(如 $i$, $j$ 和 $key$)是局部于给定过程的. 若无显式说明, 我们不使用全局变量.
    \item 数组元素通过``数组名[下标]''这样的形式来访问. 例如, $A[i]$ 表示数组 $A$ 的第 $i$ 个元素.
    \item 复合数据通常被组织成\textbf{对象}, 对象又由属性组成. 我们使用许多面向对象编程语言中创建的语法来访问特定的属性: 对象名后跟一个点再跟属性名. 例如, 数组可以看成是一个对象, 它具有属性 $length$, 表示数组包含多少元素, 如 $A.length$ 就表示数组 $A$ 中的元素数目.

    我们把表示一个数组或对象的变量看做指向表示数组或对象的数据的一个指针. 对于某个对象 $x$ 的所有属性 $f$, 赋值 $y=x$ 导致 $y.f$ 等于 $x.f$. 进一步, 若现在置 $x.f=3$, 则赋值后不但 $x.f$ 等于 3, 而且 $y.f$ 也等于 3. 换句话说, 在赋值 $y=x$ 后, $x$ 和 $y$ 指向相同的对象.

    我们的属性记号可以``级联''(cascade). 例如, 假设属性 $f$ 本身是指向某种类型的具有属性 $g$的对象的一个指针. 那么记号 $x.f.g$ 被隐含地加括号成 $(x.f).g$. 换句话说, 如果已经赋值 $y=x.f$, 那么 $x.f.g$ 与 $y.g$ 相同.

    有时, 一个指针根本不指向任何对象。这时, 我们赋给它特殊值 NIL.
    \item 我们\textbf{按值}把参数传递给过程: 被调用过程接收其参数自身的副本. 如果它对某个参数赋值, 调用过程\textbf{看不到}这种改变. 当对象被传递时, 指向表示对象数据的指针(引用)被复制, 而对象的属性却未被复制. 例如, 如果 $x$ 是某个被调用过程的参数, 在被调用过程中的赋值 $x=y$ 对调用过程是不可见的. 然而, 赋值 $x.f=3$ 却是可见的. 类似地, 数组通过指针来传递, 结果指向数组的一个指针被传递, 而不是整个数组, 单个数组元素的改变对调用过程是可见的.
    \item \kw{return} 语句立即将控制返回到调用过程的调用点. 大多数 \kw{return} 语句也将一个值传递回调用者. 我们的伪代码与许多编程语言不同, 因为我们允许在单一的 \kw{return} 语句中返回多个值.
    \item 布尔运算符 ``and'' 和 ``or'' 都是\textbf{短路}的. 也就是说, 当求值表达式 ``x and y'' 时, 首先对 $x$ 进行求值. 如果 $x$ 求值为 FALSE, 那么整个表达式不可能求值为 TRUE, 所以不再对 $y$. 另外, 如果 $x$ 求值为 TRUE, 那么就必须求值 $y$ 以确定整个表达式的值. 类似地, 对表达式 ``x or y'', 仅当 $x$ 求值为 FALSE 时, 才求值表达式 $y$. 短路的运算符使我们能书写像 ``$x \neq \text{NIL}\; \text{and}\; x.f = y$'' 这样的布尔表达式, 而不必担心当 $x$ 为 NIL 时我们试图求值 $x.f$ 将会发生什么情况.
    \item 关键词 \kw{error} 表示因为已被调用的过程情况不对而出现了一个错误. 调用过程负责处理该错误, 所以我们不用说明将采取什么行动. 
\end{itemize}

\section{分析算法}

\textbf{分析}算法的结果意味着预测算法需要的资源. 虽然有时我们主要关心像内存, 通信带宽或计算机硬件这类资源, 但是通常我们想度量的是计算时间. 一般来说, 通过分析求解某个问题的几种候选算法, 我们可以选出一种最有效的算法. 这种分析可能指出不止一个可行的候选算法, 但是在这个过程中, 我们往往可以抛弃几个较差的算法.

在能够分析一个算法之前, 我们必须有一个要使用的实现技术的模型, 包括描述所用资源及其代价的模型. 对本教程的大多数章节, 我们假定一种通用的单处理器计算模型\textbf{随机访问机}(random-access machine, RAM)来作为我们的实现技术, 算法可以用计算机程序来实现. 在 RAM 模型中, 指令一条接一条地执行, 没有并发操作. 严格地说, 我们应该精确地定义 RAM 模型的指令及其代价. 然而, 这样做既乏味又对算法的设计与分析没有多大意义. 我们还要注意不能滥用 RAM 模型. 例如, 如果一台 RAM 有一条排序指令, 会怎样呢? 这时, 我们只用一条指令就能排序. 这样的 RAM 是不现实的, 因为真实的计算机并没有这样的指令. 所以, 我们的指导性意见是真实计算机如何设计, RAM 就如何设计. RAM 模型包含真实计算机中常见的指令: 算术指令(如加法, 减法, 乘法, 除法, 取余, 向下取整, 向上取整), 数据移动指令(加载, 存储, 复制)和控制指令(条件与无条件转移, 子程序调用与返回). 每条这样的指令所需时间都为常量.

RAM 模型中的数据类型有整数型和浮点实数型. 虽然在本教程中, 我们一般不关心精度, 但是在某些应用中, 精度是至关重要的. 我们还对每个数据字的规模假定一个范围. 例如, 当处理规模为 $n$ 的输入时, 我们一般假定对某个大于等于 1 的常量 $c$, 整数由 $c\log_2n$ 位来表示. 我们要求 $c\geq 1$, 这样每个字都可以保存 $n$ 的值, 从而使我们能索引单个输入元素. 我们限制 $c$ 为常量, 这样字长就不会任意增长.(如果字长可以任意增长, 我们就能在一个字中存储巨量的数据, 并且其上的操作都在常量时间内进行, 这种情况显然不现实.)

真实的计算机包含一些上面未列出的指令, 这些指令代表了 RAM 模型中的一个灰色区域. 例如, 指数运算是一条常量时间的指令吗? 一般情况下不是; 当 $x$ 和 $y$ 都是实数时, 计算立需要若干条指令。然而, 在受限情况下, 指数运算又是一个常量时间的操作. 许多计算机都有``左移''指令, 它在常量时间内将一个整数的各位向左移 $k$ 位. 在大多数计算机中, 将一个整数的各位向左移一位等价于将该整数乘以 2, 结果将一个整数的各位向左移 $k$ 位等价于将该整数乘以 $2^k$. 所以, 只要 $k$ 不大于一个计算机字中的位数, 这样的计算机就可以由一条常量时间的指令来计算 $2^k$ 即将整数 1 向左移 $k$ 位. 我们尽量避免 RAM 模型中这样的灰色区域, 但是, 当 $k$ 是一个足够小的正整数时, 我们将把 $2^k$ 的计算看成一个常量时间的操作.

在 RAM 模型中, 我们并不试图对当代计算机中常见的内存层次进行建模. 也就是说, 我们没有对高速缓存和虚拟内存进行建模. 几种计算模型试图解释内存层次的影响, 对真实计算机上运行的真实程序, 这种影响有时是重大的. 本教程中的一些问题考查了内存层次的影响, 但是本教程的大部分分析将不考虑这些影响. 与 RAM 模型相比, 包含内存层次的模型要复杂得多, 所以可能难于使用. 此外, RAM 模型分析通常能够很好地预测实际计算机上的性能.

采用 RAM 模型即使分析一个简单的算法也可能是一个挑战. 需要的数学工具可能包括组合数学, 概率论, 代数技巧, 以及识别一个公式中最有意义的项的能力. 因为对每个可能的输入, 算法的行为可能不同, 所以我们需要一种方法来以简单的, 易于理解的公式的形式总结那样的行为.

即使我们通常只选择一种机器模型来分析某个给定的算法, 在决定如何表达我们的分析时仍然面临许多选择. 我们想要一种表示方法, 它的书写和处理都比较简单, 并能够表明算法资源需求的重要特征, 同时能够抑制乏味的细节.

\textbf{插入排序算法的分析}

过程\proc{Insertion-Sort}需要的时间依赖于输入: 排序 1000 个数比排序 3 个数需要更长的时间. 此外, 依据它们已被排序的程度, \proc{Insertion-Sort}可能需要不同数量的时间来排序两个具有相同规模的输入序列. 一般来说, 算法需要的时间与输入的规模同步增长, 所以通常把一个程序的运行时间描述成其输入规模的函数. 为此, 我们必须更仔细地定义术语``运行时间''和``输入规模''.

输入规模的最佳概念依赖于研究的问题. 对许多问题, 如排序, 最自然的量度是输入中的项数, 例如, 待排序数组的规模 $n$. 对其他许多问题, 如两个整数相乘, 输入规模的最佳量度是用通常的二进制记号表示输入所需的总位数. 有时, 用两个数而不是一个数来描述输入规模可能更合适. 例如, 若某个算法的输入是一个图, 则输入规模可以用该图中的顶点数和边数来描述. 对于研究的每个问题, 我们将指出所使用的输入规模量度.

一个算法在特定输入上的运行时间是指执行的基本操作数或步数. 定义``步''的概念以便尽量独立于机器是方便的. 目前, 让我们采纳以下观点, 执行每行伪代码需要常量时间. 虽然一行与另一行可能需要不同数量的时间, 但是我们假定第 $i$ 行的每次执行需要时间 $c_i$, 其中 $c_i$ 是一个常量. 这个观点与 RAM 模型是一致的, 并且也反映了伪代码在大多数真实计算机上如何实现气在下面的讨论中, 我们由繁到简地改进\proc{Insertion-Sort} 运行时间的表达式, 最初的公式使用所有语句代价 $c_i$, 而最终的记号则更加简明, 更容易处理, 简单得多. 这种较简单的记号比较易于用来判定一个算法是否比另一个更有效.

我们首先给出过程 \proc{Insertion-Sort} 中, 每条语句的执行时间和执行次数. 对 $i=2, 3, \dots, n$, 假设 $t_i$ 表示对那个值 $i$ 第 5 行执行 \kw{while} 循环测试的次数. 当一个 \kw{for} 或 \kw{while} 循环按通常的方式(即由于循环头中的测试)退出时, 执行测试的次数比执行循环体的次数多 1 . 我们假定注释是不可执行的语旬, 所以它们不需要时间.

\newcommand{\myquad}[1][1]{\hspace*{#1em}\ignorespaces}
\begin{codebox}
\Procname{$\proc{Insertion-Sort}(A, n) \myquad[16] \text{代价}$ \quad \text{次数}}
\li \For $i \gets 2$ \To $n$ \myquad[18] $c_1$ \quad\quad $n$
\li \Do
$\id{key} \gets A[i]$ \myquad[17]\; $c_2$ \quad\quad $n-1$
\li \Comment{将 $A[i]$ 插入到已经排好序的子数组 $A[1 \subarr i-1]$.} \; $0$ \quad\quad\ $n-1$
\li $j \gets i-1$ \myquad[18]\ $c_4$ \quad\quad $n-1$
\li \While $j > 0$ and $A[j] > \id{key}$ \myquad[10]\ $c_5$ \quad\;\; $\sum_{i=2}^{n}t_i$
\li \Do
$A[j+1] \gets A[j]$ \myquad[13]\ $c_6$ \; $\sum_{i=2}^{n}(t_i-1)$
\li $j \gets j-1$ \myquad[16] $c_7$ \; $\sum_{i=2}^{n}(t_i-1)$
\End
\li $A[j+1] \gets \id{key}$ \myquad[16] $c_8$ \quad\quad $n-1$
\End
\end{codebox}

该算法的运行时间是执行每条语句的运行时间之和. 需要执行$c_i$步且执行 $n$ 次的一条语句将贡献$c_in$给总运行时间. 为计算在具有 $n$ 个值的输入上 \proc{Insertion-Sort} 的运行时间 $T[n]$, 我们将代价与次数列对应元素之积求和, 得:

\begin{equation*}\begin{split}
T(n) =\; &c_1n + c_2(n-1) + c_4(n-1) + c_5\sum_{i=2}^{n}t_i + c_6\sum_{i=2}^{n}(t_i-1) \\
&+c_7\sum_{i=2}^{n}(t_i-1) + c_8(n-1)
\end{split}\end{equation*}

即使对给定规模的输入, 一个算法的运行时间也可能依赖于给定的是该规模下的哪个输入. 例如, 在 \proc{Insertion-Sort} 中, 若输入数组已排好序, 则出现最佳运行情况. 在这种情况下, 每次执行第 5 行时, \id{key}的值--最开始在$A[i]$的值--已经大于等于$A[1:i-1]$中的所有值, 直到第 5-7 行的\kw{while}循环退出. 所以对于$i = 2,3,\dots,n$, 有$t_i=1$, 那么最好情况的运行时间如下:

\begin{equation}\begin{aligned}
T(n) &= c_1n + c_2(n-1) + c_4(n-1) + c_5(n-1) + c_8(n-1) \\
     &= (c_1+c_2+c_4+c_5+c_8)n - (c_2+c_4+c_5+c_8)
\end{aligned}\end{equation}

我们可以把该运行时间表示为 $an+b$, 其中常量 $a$ 和 $b$ 依赖于语句代价$c_k$(其中$a=c_1+c_2+c_4+c_5+c_8\text{以及}b=c_2+c_4+c_5+c_8$). 因此, 它是 $n$ 的\textbf{线性函数}.

若输入数组已反向排序, 即按递减序排好序, 则导致最坏运行情况. 我们必须将每个元素 $A[i]$ 与整个已排序子数组 $A[1:i—1]$ 中的每个元素进行比较, 所以对 $i=2,3,\dots,n$, 有 $t_i=i$.(这个过程会发现每次执行第 5 行时, 有$A[j]>key$, 以及只有当 $j$ 到达 0 时, \kw{while}才会退出.) 注意到

\begin{equation*}\begin{split}
\sum_{i=2}^{n}i &= (\sum_{i=1}^{n}i) - 1 \\
                &= \frac{n(n+1)}{2} - 1
\end{split}\end{equation*}

以及

\begin{equation*}\begin{split}
\sum_{i=2}^{n}(i-1) &= \sum_{i=1}^{n-1}i \\
                    &= \frac{n(n-1)}{2}
\end{split}\end{equation*}

我们发现在最坏情况下, \proc{Insertion-Sort} 的运行时间为

\begin{equation}\begin{aligned}
T(n) =\; &c_1n + c_2(n-1) + c_4(n-1) + c_5(\frac{n(n+1)}{2}-1) \\
&+c_6(\frac{n(n-1)}{2})+c_7(\frac{n(n-1)}{2})+c_8(n-1) \\
=\; &(\frac{c_5}{2}+\frac{c_6}{2}+\frac{c_7}{2})n^2 + (c_1+c_2+c_4+\frac{c_5}{2}-\frac{c_6}{2}-\frac{c_7}{2}+c_8)n \\
&-(c_2+c_4+c_5+c_8)
\end{aligned}\end{equation}

我们可以把该最坏情况运行时间表示为 $an^2+bn+c$, 其中常量 $a$, $b$ 和 $c$ 又依赖于语句代价 $c_k$. 因此, 它是 $n$ 的\textbf{二次函数}.

\textbf{最坏情况与平均情况分析}

在分析插入排序时, 我们既研究了最佳情况, 其中输入数组已排好序, 又研究了最坏情况, 其中输入数组已反向排好序. 然而, 在本教程的余下部分中, 我们往往集中于只求\textbf{最坏情况运行时间}, 即对规模为 $n$ 的任何输入, 算法的最长运行时间. 下面给出这样做的三点理由:

\begin{itemize}
    \item 一个算法的最坏情况运行时间给出了任何输入的运行时间的一个上界. 知道了这个界, 就能确保该算法绝不需要更长的时间. 我们不必对运行时间做某种复杂的猜测并可以期望它不会变得更坏.
    \item 对某些算法, 最坏情况经常出现. 例如, 当在数据库中检索一条特定信息时, 若该信息不在数据库中出现, 则检索算法的最坏情况会经常出现. 在某些应用中, 对缺失信息的检索可能是频繁的.
    \item ``平均情况''往往与最坏情况大致一样差. 假定随机选择 $n$ 个数并应用插入排序. 需要多长时间来确定在子数组 $A[1:i-1]$ 的什么位置插入元素 $A[i]$? 平均来说, $A[1:j-1]$中的一半元素小于 $A[i]$, 一半元素大于 $A[i]$. 所以, 平均来说, 我们检查子数组$A[1:i-1]$的一半, 那么 $t_i$ 大约为$i/2$. 导致的平均情况运行时间结果像最坏情况运行时间一样, 也是输入规模的一个二次函数.
\end{itemize}

\textbf{增长量级}

我们使用某些简化的抽象来使过程 \proc{Insertion-Sort} 的分析更加容易. 首先, 通过使用常量 $c_k$ 表示这些代价来忽略每条语句的实际代价. 其次, 注意到这些常量也提供了比我们真正需要的要多的细节: 把最坏情况运行时间表示为 $an^2+bn+c$, 其中常量 $a$, $b$ 和 $c$ 依赖于语句代价$c_k$. 这样, 我们不但忽略实际的语句代价, 而且也忽略抽象的代价 $c_k$.

现在我们做出一种更简化的抽象: 即我们真正感兴趣的运行时间的增长率或增长量级. 所以我们只考虑公式中最重要的项(例如, $an^2$), 因为当 $n$ 的值很大时, 低阶项相对来说不太重要. 我们也忽略最重要的项的常系数, 因为对大的输入, 在确定计算效率时常量因子不如增长率重要. 对于插入排序, 当我们忽略低阶项和最重要的项的常系数时, 只剩下最重要的项中的因子$n^2$. 举个例子, 假设一个算法的输入规模是$n$, 而在某一台特定的机器上面需要执行的时间是$n^2/100+100n+17$微秒. 尽管$n^2$的系数$1/100$相比$n$的系数$100$小了4个数量级, 但是当 $n$ 超过 $10,000$ 时, $n^2/100$将会越来越拉大和$100n$的差距. 尽管 $10,000$ 看起来是个很大的输入规模, 实际上相对于实际情况, 可以说这个数量是不值一提的. 很多显示的问题, 有着大得多的输入数据规模.

为了强调运行时间的增长量级, 我们使用一个特殊的希腊字母$\Theta$(theta). 例如插入排序的最坏情况运行时间, 我们写作$\Theta(n^2)$. 插入排序的最好情况运行时间我们写作$\Theta(n)$. 现在, 我们可以把$\Theta(f(n))$表示法理解为: 当$n$很大时和$f(n)$成比例增长. 所以$\Theta(n^2)$的意思是: 当$n$很大时, 和$n^2$成比例增长. $\Theta(n)$的意思是: 当$n$很大时, 和$n$成比例增长. 后面我们会形式化的讨论$\Theta$表示法.

如果一个算法的最坏情况运行时间具有比另一个算法更低的增长量级, 那么我们通常认为前者比后者更有效. 由于常量因子和低阶项, 对于小的输入, 运行时间具有较高增长量级的一个算法与运行时间具有较低增长量级的另一个算法相比, 其可能需要较少的时间. 但对于足够大的输入规模, 如果一个算法的最坏情况运行时间是$\Theta(n^2)$, 那么会比最坏情况运行时间是$\Theta(n^3)$的算法所花的时间要少. 无论$\Theta$表示法中隐藏的常数是多少, 总会有一个数$n_0$, 对于输入规模$n\geq n_0$, 在最坏情况下, $\Theta(n^2)$的算法会打败$\Theta(n^3)$的算法.

\section{设计算法}

我们可以选择使用的算法设计技术有很多. 插入排序使用了\textbf{增量}方法: 在排序子数组$A[1:i-1]$后, 将单个元素 $A[i]$ 插入子数组 $A[1:i]$ 的适当位置.

本节我们考查另一种称为``分治法''的设计方法. 第 4 章将更深入地探究该方法. 我们将用分治法来设计一个排序算法, 该算法的最坏情况运行时间比插入排序要少得多. 分治算法的优点之一是, 通过使用第 4 章介绍的技术往往很容易确定其运行时间.

\subsection{分治法}

许多有用的算法在结构上是递归的: 为了解决一个给定的问题, 算法一次或多次递归地调用其自身以解决紧密相关的若干子问题. 这些算法典型地遵循分治法的思想: 将原问题分解为几个规模较小但类似于原问题的子问题, 递归地求解这些子问题, 然后再合并这些子问题的解来建立原问题的解.

分治模式在每层递归时都有三个步骤:

分解原问题为若干子问题, 这些子问题是原问题的规模较小的实例.

解决这些子问题, 递归地求解各子问题. 然而, 若子问题的规模足够小, 则直接求解.

合并这些子问题的解成原问题的解.

归井排序算法完全遵循分治模式. 直观上其操作如下:

分解: 分解待排序的 $n$ 个元素的序列成各具 $n/2$ 个元素的两个子序列.

解决: 使用归并排序递归地排序两个子序列.

合并: 合并两个已排序的子序列以产生已排序的答案.

当待排序的序列长度为 1 时, 递归``开始回升'', 在这种情况下不要做任何工作, 因为长度为 1 的每个序列都巳排好序.

归并排序算法的关键操作是``合并''步骤中两个已排序序列的合并. 我们通过调用一个辅助过程 MERGE(A, p, q, r) 来完成合并, 其中 $A$ 是一个数组, $p$, $q$ 和 $r$ 是数组下标，满足 $p\leq q<r$. 该过程假设子数组 $A[p:q]$ 和 $A[q+1:r]$ 都已排好序. 它合并这两个子数组形成单一的已排好序的子数组并代替当前的子数组 $A[p:r]$.

\subsection{分析分治算法}

\chapter{函数的增长}

\section{渐进记号}

\section{标准记号和常用函数}

\chapter{分治策略}

\section{最大子数组问题}

\section{用代入法求解递归式}



\part{排序和顺序统计量}

\chapter{堆排序}

\chapter{快速排序}

\chapter{线性时间排序}

\chapter{中位数和顺序统计量}

\part{数据结构}

\chapter{基本数据结构}

\chapter{哈希表}

\chapter{二叉搜索树}

\chapter{红黑树}

\chapter{B树}

\part{高级设计和分析技术}

\chapter{动态规划}

\chapter{贪心算法}

\part{图算法}

\chapter{图的表示}

\chapter{深度优先搜索}

\chapter{广度优先搜搜}

\chapter{拓扑排序}

\chapter{迪克斯特拉算法}

\part{算法问题选编}

\chapter{数论算法}

\chapter{字符串匹配}

\part{力扣算法题选讲}

\chapter{两数之和}



\end{document}