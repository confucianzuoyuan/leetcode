# 题目

给定一个字符串 (`s`) 和一个字符模式 (`p`), 实现一个支持 `'?'` 和 `'*'` 的通配符匹配.

`'?'` 可以匹配任何单个字符.
`'*'` 可以匹配任意字符串(包括空字符串).

两个字符串完全匹配才算匹配成功.

**说明**:

- `s` 可能为空, 且只包含从 `a-z` 的小写字母.
- `p` 可能为空, 且只包含从 `a-z` 的小写字母, 以及字符 `?` 和 `*`.

\textbf{示例 1}:

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串. 
```

\textbf{示例 2}:

```
输入:
s = "aa"
p = "*"
输出: true
解释: '*' 可以匹配任意字符串. 
```

\textbf{示例 3}:

```
输入:
s = "cb"
p = "?a"
输出: false
解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'. 
```

\textbf{示例 4}:

```
输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
```

**示例 5**:

```
输入:
s = "acdcb"
p = "a*c?b"
输出: false
```

# 解法

其实, 我们发现这道题目是让我们来实现一个正则表达式的子集语法.

一般解法使用的是动态规划法, 但我们这里想使用一些比较"正"的解法, 也就是我们自己使用通行的算法来实现一个正则表达式引擎.

## 有限自动机

在非正式术语中, 有限自动机(或有限状态机)是一种抽象机器, 具有状态和状态之间的转换. 它始终处于其中一种状态, 并且在读取输入时会从一个状态切换到另一个状态. 它有一个开始状态, 可以有一个或多个结束(接受)状态.

### 确定性有限自动机(DFA)

<img id="fig1.1" src="images/44-1.png" />
<p class="text-center"><small>图 1.1: 确定性有限自动机(DFA)</small></p>

在[图 1.1](#fig1.1)中, 我们有四个状态的自动机; $q_0$ 称为起始状态, 并且 $q_3$ 是结束(接受)状态. 它识别所有以 `"ab"` 开头, 后跟任意数量的 `"b"` 并以 `"a"` 结尾的字符串.

如果我们通过[图 1.1](#fig1.1)中的机器处理字符串 `"abba"`, 我们将经历以下状态:


| Step |     State         | Input             | New State             |
|:----:|:-----------------:|:-----------------:|:---------------------:|
| 0    |     $q_0$         | a                 | $q_1$                 |
| 1    |     $q_1$         | b                 | $q_2$                 |
| 2    |     $q_2$         | b                 | $q_2$                 |
| 3    |     $q_2$         | a                 | $q_3$                 |

对于字符串 `"aba"`, `"abbba"` 或 `"abbbba"`, 自动机最终将处于接受状态 $q_3$. 如果在处理过程中的任何时候, 对于给定的输入符号, 机器没有可遵循的状态 - 它会停止执行并且无法识别字符串. 所以它不会识别 `"ab"`, 因为它最终会处于非接受状态 $q_2$. 对于 `"abca"`, 因为接收到字符 `"c"` 时, 从 $q_2$ 没有可以跳转到的状态. 在[图 1.1](#fig1.1)的示例中, 对于给定的有效输入符号, 在每个状态下, 我们可以恰好处于一个状态, 我们说机器是确定性的(DFA).

### 非确定性有限自动机(NFA)

假设我们有以下自动机:

<img id="fig1.2" src="images/44-2.png" />
<p class="text-center"><small>图 1.2: 非确定性有限自动机(NFA)</small></p>

从[图 1.2](#fig1.2)可以看出 $q_1$ 在接收到输入 `'b'` 时, 我们可以转换到两个状态-$q_1$ 和 $q_2$. 在这种情况下, 我们说机器是不确定的(NFA). 很容易看出这台机器与[图 1.1](#fig1.1)中的那台机器是等价的, 即它们识别的是同一组字符串. 每个 NFA 都可以转换为相应的 DFA, 证明和转换是另一篇文章的主题.

### &epsilon;-NFA

我们完全按照 NFA 来表示 &epsilon;-NFA, 但有一个例外. 它包括空字符串-&epsilon;上的转换. 这意味着我们可以在不读取输入符号的情况下从一种状态转换到另一种状态. 这些跃迁通常用希腊字母&epsilon;(epsilon)表示.

<img id="fig1.3" src="images/44-3.png" />
<p class="text-center"><small>图 1.3: &epsilon;-NFA</small></p>

在[图 1.3](#fig1.3)中, 我们可以看到有从 $q_2$ 到 $q_1$ 的 **&epsilon;-transition**. 这个 &epsilon;-NFA 等价于[图 1.2](#fig1.2)中的 NFA .

## 将正则表达式编译为有限自动机

有限自动机识别的字符串集A被称为的语言A并表示为大号(一个). 如果一种语言可以被有限自动机识别, 那么就有一个相应的正则表达式来描述相同的语言, 反之亦然(Kleene定理). 相当于[图 1.1](#fig1.1)中的自动机的正则表达式是 `abb*a`. 换句话说, 正则表达式可以被认为是有限自动机的一种用户友好的替代方法, 用于描述文本中的模式.

### 汤普森构造法

各种代数都以一些初等表达式开始, 通常是常数和/或变量. 然后, 它们允许我们通过对这些基本表达式应用一组特定的操作来构造更复杂的表达式. 通常, 还需要一些将运算符与其操作数(例如括号)分组的方法.

例如, 在算术代数中, 我们从整数和实数等常量开始, 包括变量, 并使用算术运算符(例如+、×)构建更复杂的表达式. 正则表达式在某种程度上没有什么不同. 使用常量, 变量和运算符作为构建块, 它们表示形式语言(字符串集).

我们将描述Ken Thompson在他的论文 **正则表达式搜索算法(1968)** 中提出的实现.

编译正则表达式 $R$ 到 NFA 我们首先需要解析 $R$ 进入其组成子表达式. 构建 NFA 的规则可以分为两部分:

1. 处理不带运算符的子表达式的基本规则.
2. 通过应用运算符从较小的 NFA 构建较大的 NFA 的归纳规则.

#### 基础

<img id="fig2.1" src="images/44-4.png" />
<p class="text-center"><small>图 2.1: 表达式&epsilon;的有限自动机</small></p>

在[图 2.1](#fig2.1)中, 我们有一个识别空字符串 $\epsilon$ 的有限自动机. $i$ 是开始状态, $f$ 是接受状态.

<img id="fig2.2" src="images/44-5.png" />
<p class="text-center"><small>图 2.2: 表达式<em>a</em>的有限自动机</small></p>

在[图 2.3](#fig2.3)中, 我们为符号 `'a'` 构造了自动机. 我们把输入的字母自身都看作一个正则表达式. 自动机的语言只包含一个单词 `'a'`.

#### 归纳

假设我们有两个正则表达式 $S$ 和 $T$, 它们的 NFA 分别是 $N(S)$ 和 $N(T)$:

a) **Union**: $R = S | T$

或操作. 我们引入了一个开始状态 $i$, 然后添加 $i$ 到 $N(S)$ 和 $N(T)$ 的开始状态的&epsilon;-transition(空转换). 接下来, 我们添加 $N(S)$ 和 $N(T)$ 的结尾状态到状态 $f$ 的空转换. 并将 $N(S)$ 和 $N(T)$ 的开始状态和结尾状态都标记为未接受状态. 那么我们画出来的自动机就会接收属于 $L(S)$ 和属于 $L(T)$ 的字符串了.

